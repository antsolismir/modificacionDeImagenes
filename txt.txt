import PIL

import filtros
import functions as f
import utils as u
import plots_and_statistics as p
import numpy as np
import pandas as pd

import streamlit as st

# CODE FOR PAGE CONFIGURATION FRONT END 
st.set_page_config(page_title="Comparar efectos - PSM Universidad de Sevilla", layout="centered")

input_box_image = st.text_input("Imagen a comparar", value=None)
file = st.file_uploader("Sube una imagen", type=["png", "jpg"])

col_options_1,col_options_2,col_options_3,col_options_4 = st.columns(4)
bn = col_options_1.checkbox("Blanco y negro", value=False)
color_check = col_options_2.checkbox("Mascara de color", value=False)
channel_check = col_options_3.checkbox("Cambio de canal RGB", value=False)
fake_check = col_options_4.checkbox("Fake color", value=False)

image = None
if input_box_image != None and file != None:
    image = u.read_image_path(input_box_image)
elif input_box_image != None and file == None:
    image = u.read_image_path(input_box_image)
elif file != None and input_box_image == None:
    image = u.read_image_file(file)
else:
    pass


if image != None:
    
    if image.mode == 'L':
        text='Está subiendo una imagen que está en formato BLANCO y NEGRO. El formato soportado es RGB. Es posible que no tenga todas las opciones de las que dispone la aplicación. Formato de la imagen:',image.mode
        st.warning(text)
    elif image.mode != 'RGB' or image.mode == 'RGB':
        image = image.convert('RGB')
        
        st.subheader("Imagen")
        col_original_1, col_original_2 = st.columns(2)
        col_original_1.image(image,caption='Imagen original')
        col_original_2.image(p.histograma_color(image), caption='Histograma de la imagen original')
        
        if bn != False:
            with st.expander("Blanco y negro"):
                col_1, col_2 = st.columns(2)
                new_image_black_white = f.image_to_gray(imagen=image)
                histograma_bn = p.histograma_blanco_negro(new_image_black_white)
                col_1.image(new_image_black_white,caption='Imagen en blanco y negro')
                col_2.image(histograma_bn, caption='Histograma de la imagen en blanco y negro')

        if color_check != False:
            with st.expander("Mascara de color"):
                col_1, col_2, col_3 = st.columns(3)
                color = col_1.color_picker(label = 'Color de la mascara', value=None)
                new_image_colored = f.image_to_hex_color(image, color)
                histograma_color_mascara = p.histograma_color(new_image_colored)
                col_2.image(new_image_colored,caption='Imagen con mascara del color seleccionado')
                col_3.image(histograma_color_mascara, caption='Histograma de la imagen con mascara')

        if channel_check != False:
            with st.expander("Canales RGB"):
                col_1, col_2, col_3 = st.columns(3)
                channel = col_1.radio("Canal RGB", ["Red","Green","Blue"])
                new_image_channel = f.image_to_one_channel(imagen=image,channel=channel)
                histograma_color_channel = p.histograma_color(new_image_channel)
                col_2.image(new_image_channel,caption='Canal seleccionado de la imagen original')
                col_3.image(histograma_color_channel, caption='Histograma de la imagen con solo un canal')

        if fake_check != False:
            with st.expander("Fake color"):
                col_1, col_2 = st.columns(2)
                x = np.linspace(0, 256, 256)
                tecnica = st.radio("Transformacion de la grafica para entrar en 0 y 1", ["Clipping","Normalizar"])
                string_red = st.text_input("Funcion RED",value='1-0.0039*x')
                st.write('Puede probar tambien con funciones mas complejas, por ejemplo: 0.5*cos(0.1*x-150)+0.5')
                string_green = st.text_input("Funcion GREEN", value='0.0039*x')
                st.write('Puede probar tambien con funciones mas complejas, por ejemplo: 0.5*sin(0.1*x-1)+0.5')
                string_blue = st.text_input("Funcion BLUE", value='0.5')
                st.write('Puede probar tambien con funciones mas complejas, por ejemplo: x/256 - floor(x/256)')
                
                if string_red != '' and string_green != '' and string_blue != '':
                    
                    red = u.string2func(string_red)
                    green = u.string2func(string_green)
                    blue = u.string2func(string_blue)
                    
                    if tecnica == 'Clipping':
                        y_red=u.encuadre(red(x))
                        y_green=u.encuadre(green(x))
                        y_blue=u.encuadre(blue(x))
                    else:
                        y_red=u.normalizacion(red(x))
                        y_green=u.normalizacion(green(x))
                        y_blue=u.normalizacion(blue(x))
                
                    chart_data = pd.DataFrame(
                        {
                            "x": x,
                            "Red": y_red,
                            "Green": y_green,
                            "Blue": y_blue,
                        }
                    )
                    col_2.line_chart(chart_data, x="x", y=["Red", "Blue", "Green"], color=["#0000ff","#00ff00","#ff0000"])
                    new_image_fake_color = p.image_bn_to_fake_color(image,y_red,y_green,y_blue)
                    col_1.image(new_image_fake_color, caption='Imagen en Fake Color de la imagen en Blanco y Negro')
        
        if bn != False:
            with st.expander("Filtros pasa alta y baja"):
                
                col_s_1, col_s_2, col_s_3, col_s_4 = st.columns(4)
                col_t_1, col_t_2, col_t_3, col_t_4 = st.columns(4)
                col_r_1, col_r_2 = st.columns(2)
                
                tam = st.slider("Tamaño de la imagen de la imagen resultante", 512, 1000,step=2)
                slider1 = col_s_1.slider("Sigma pasa de baja ideal", 0, 100)
                f_pasa_baja_ideal = filtros.filtro_pasa_baja_ideal(new_image_black_white,tam,slider1)
                slider2 = col_s_2.slider("Sigma pasa de baja no ideal", 0.0, 1.0,value=0.01)
                f_pasa_baja_no_ideal = filtros.filtro_pasa_baja_no_ideal(new_image_black_white,tam,slider2)
                slider3 = col_s_3.slider("Sigma pasa de alta ideal", 0, 100)
                f_pasa_alta_ideal = filtros.filtro_pasa_alta_ideal(new_image_black_white,tam,slider3)
                slider4 = col_s_4.slider("Sigma pasa de alta no ideal", 0.0, 1.0,value=0.01)
                f_pasa_alta_no_ideal = filtros.filtro_pasa_alta_no_ideal(new_image_black_white,tam,slider4)
                
                #SHOW THE PLOTS
                col_t_1.image(f_pasa_baja_ideal, caption='Filtro pasa de baja ideal')
                col_t_2.image(f_pasa_baja_no_ideal, caption='Filtro pasa de baja no ideal')
                col_t_3.image(f_pasa_alta_ideal, caption='Filtro pasa de alta ideal')
                col_t_4.image(f_pasa_alta_no_ideal, caption='Filtro pasa de alta no ideal')
                
                f_suma = f.image_plus_image(new_image_black_white,f_pasa_alta_no_ideal)
                col_r_1.image(new_image_black_white.resize((tam,tam)), caption='Imagen original en blanco y negro')
                col_r_2.image(f_suma, caption='Sharpening (Imagen original + Filtro pasa alta no ideal)')
                
        if bn != False:
            with st.expander("Binarizacion"):
                col_b_1, col_b_2 = st.columns(2)
                col_b_3, col_b_4 = st.columns(2)
                
                umbral = col_b_1.slider("Umbral", 0, 255,step=1)
                f_binarizacion_umbral = p.binarizacion_por_umbral(new_image_black_white, umbral)
                col_b_2.image(f_binarizacion_umbral, caption='Binarizacion con umbral de {}'.format(umbral))
                
                tam = col_b_3.slider("Numero de vecinos para los que realizar la media", 3, 15,step=2)
                f_binarizacion_entorno = p.binarizacion_entorno(new_image_black_white,tam)
                texto = 'Binarizacion por entorno: Media de vecinos {}x{}'.format(tam, tam)
                col_b_4.image(f_binarizacion_entorno, caption=texto)
                
                
                
        
    else:
        text='Está subiendo una imagen que está en formato no soportado. Los formatos soportados son RGB y Blanco y Negro (L). Vuelva a subir otra imagen con los formatos soportados. Formato de la imagen',image.mode
        st.warning(text)
else:
    pass











from PIL import Image
import PIL
import requests
import numpy as np
import io
import re
import matplotlib.pyplot as plt

def check_channel(array,channel):
    red = 0; blue = 0; green = 0
    if channel == 'Red':
        red = array[0]
    elif channel == 'Green':
        green = array[1]
    elif channel == 'Blue':
        blue = array[2]
    else:
        raise Exception("Sorry, only channels: red, green and blue.")
    return (red,green,blue)

def hex_to_rgb(hex):
    if hex[0] == '#':
        hex = hex.replace('#', '')
    return tuple(int(hex[i:i+2], 16) for i in (0, 2, 4))

def read_image_path(path):
    image = PIL.Image.open('img/generic_error.png')
    try:
        if path[0:4]=='http':
            image=PIL.Image.open(requests.get(path, stream=True).raw)
        else:
            try:
                image=PIL.Image.open(path)
            except:
                pass
        return image
    except:
        return image

def read_image_file(file):
    image = PIL.Image.open('img/generic_error.png')
    try:
        image = PIL.Image.open(file)
    except Exception as e:
        print(e)
    return image

def fig2img(fig): 
    buf = io.BytesIO() 
    fig.savefig(buf) 
    buf.seek(0) 
    img = Image.open(buf) 
    return img

def encuadre(array):
    sol = list()
    for n in array:
        if n >= 1:
            sol.append(1)
        elif n<=0:
            sol.append(0)
        else:
            sol.append(n)
    return sol

def normalizacion(array):
    maximo = max(array)
    minimo = min(array)
    n_array = []
    for valor in array:
        if maximo == minimo:
            n_array.append(maximo)
        else:
            n_array.append((valor - minimo) / (maximo - minimo))
            
    return n_array

replacements = {
    'sin' : 'np.sin',
    'cos' : 'np.cos',
    'exp': 'np.exp',
    'sqrt': 'np.sqrt',
    'floor': 'np.floor',
    'ceil': 'np.ceil',
    '^': '**',
}

allowed_words = [
    'x',
    'sin',
    'cos',
    'sqrt',
    'exp',
    'floor',
    'ceil',
]

def string2func(string):
    try:
        lista = list()
        for word in re.findall('[a-zA-Z_]+', string):
            lista.append(word)
            if word not in allowed_words:
                raise ValueError(
                    '"{}" is forbidden to use in math expression'.format(word)
                )

        for old, new in replacements.items():
            string = string.replace(old, new)
            
        if string.find('x') == -1:
            string += '+0*x'
        
        def func(x):
            return eval(string)
        
        return func
    except Exception as e:
        return e

if __name__ == '__main__':
    x = np.linspace(0, 256, 256)
    y = 0.5+0.0*x
    print(normalizacion(y))


from PIL import Image
import PIL
import requests
import numpy as np
import utils as utilities

###################################
#                                 #
# This is where the magic happens #
#                                 #
###################################

# METHODS TO CREATE IMAGES
def create_image(color, ancho, alto):
    tam_x=ancho
    tam_y=alto
    
    pixels = []
    red,green,blue = utilities.hex_to_rgb(color)
    x=0
    y=0
    while y < tam_y:
        pixels.append((red, green, blue))
        x+=1
        if x >= tam_x:
            x=0
            y+=1
    im = PIL.Image.new("RGB", (ancho, alto))
    im.putdata(pixels)
    return im
#============================#

# METHODS TO CHANGE IMAGE COLOR
def image_to_one_channel(imagen,channel):
    #imagen = PIL.Image.open(image)
    old_image = imagen.load()
    ancho, alto = imagen.size
    new_image = []
    x=0; y=0
    while y < alto:
        pixel = utilities.check_channel(old_image[x,y],channel)
        new_image.append(pixel)
        x+=1
        if x >= ancho:
            x=0
            y+=1
    
    sol = PIL.Image.new("RGB", (ancho, alto))
    sol.putdata(new_image)
    return sol

def image_to_hex_color(imagen, color_hex):
    #imagen = PIL.Image.open(imagen_path)
    ancho, alto = imagen.size

    rgb = utilities.hex_to_rgb(color_hex)
    pixels_imagen = imagen.load()
    imagen_combinada = []

    x=0; y=0
    while y < alto:
        red, green, blue = pixels_imagen[x,y]
        intensidad = int((299/1000)*red) + int((587/1000)*blue) + int((114/1000)*green)
        r_mascara=rgb[0];g_mascara=rgb[1];b_mascara=rgb[2]
        
        r_combinado = (intensidad * r_mascara) // 255
        g_combinado = (intensidad * g_mascara) // 255
        b_combinado = (intensidad * b_mascara) // 255
        
        imagen_combinada.append((r_combinado,g_combinado,b_combinado))
        x+=1
        if x >= ancho:
            x=0
            y+=1

    sol = PIL.Image.new("RGB", (ancho, alto))
    sol.putdata(imagen_combinada)
    return sol

def image_to_gray(imagen):
    #La formula para cambiar de color (RGB) a blanco y negro (gris) es la siguiente: Y = 0.299xR + 0.587xG + 0.114xB
    #imagen = PIL.Image.open(image)
    old_image = imagen.load()
    ancho, alto = imagen.size
    new_image = []
    x=0; y=0
    while y < alto:
        red = old_image[x,y][0]; blue = old_image[x,y][1]; green = old_image[x,y][2]
        luminance = int((299/1000)*red) + int((587/1000)*blue) + int((114/1000)*green)
        new_image.append(luminance)
        x+=1
        if x >= ancho:
            x=0
            y+=1
    
    sol = PIL.Image.new("L", (ancho, alto))
    sol.putdata(new_image)
    return sol

def image_plus_image(imagen1,imagen2):
    #La formula para cambiar de color (RGB) a blanco y negro (gris) es la siguiente: Y = 0.299xR + 0.587xG + 0.114xB
    #imagen = PIL.Image.open(image)
    ancho, alto = imagen2.size
    imagen1 = imagen1.resize(imagen2.size)
    imagen2 = imagen2.load()
    imagen1 = imagen1.load()
    new_image = []
    x=0; y=0
    while y < alto:
        luminance = (imagen1[x,y]+imagen2[x,y])/2
        new_image.append(luminance)
        x+=1
        if x >= ancho:
            x=0
            y+=1
    
    sol = PIL.Image.new("L", (ancho, alto))
    sol.putdata(new_image)
    return sol
#============================#







from PIL import Image
import PIL
import requests
import numpy as np
import matplotlib.pyplot as plt
import utils as utilities
import functions as f
import cv2
import statistics as s

def histograma_blanco_negro(imagen):
    ancho, alto = imagen.size
    matrix = np.zeros([256])
    if imagen.mode != 'L':
        imagen = imagen.convert("L")
    imagen = imagen.load()
    x=0
    y=0
    while y < alto:
        matrix[imagen[x,y]] += 1
        x+=1
        if x >= ancho:
            x=0
            y+=1
    
    x = np.arange(len(matrix))
    y = np.array(matrix)
    plt.title("Histograma de la imagen en blanco y negro")
    plt.xlabel("Rango de grises") 
    plt.ylabel("Numero de pixeles") 
    plt.bar(x, y, color ="blue") 
    grafica = utilities.fig2img(plt.gcf())
    plt.clf()
    return grafica

def rgb_to_hsl(rgb):
    r, g, b = rgb
    
    r = r/255.0
    g = g/255.0
    b = b/255.0
    
    maximo = max(r, g, b)
    minimo = min(r, g, b)
    delta = maximo - minimo

    # Calcular el componente Lightness
    L = (maximo + minimo)/2.0
    
    if maximo == minimo:
        S = 0.0
        H = 0.0
    else:
        S = (maximo - minimo)/(1.0 - abs(2.0 * L - 1.0))
        
        # Calcular el componente Hue
        if maximo == r:
            H = (g - b) / delta
        elif maximo == g:
            H = 2.0 + (b - r) / delta
        else:
            H = 4.0 + (r - g) / delta

        if H != None:
            H = H * 60.0
            if H < 0.0:
                H = H + 360.0

    return (int(H), int(S*100), int(L*100))

def histograma_color(imagen):
    ancho, alto = imagen.size
    matrix = np.zeros([360])
    if imagen.mode != 'RGB':
        imagen = imagen.convert("RGB")
    imagen = imagen.load()
    x=0
    y=0
    while y < alto:
        pixel_hsl = rgb_to_hsl(imagen[x,y])
        matrix[pixel_hsl[0]] += 1
        x+=1
        if x >= ancho:
            x=0
            y+=1
    
    x = np.arange(len(matrix))
    y = np.array(matrix)
    plt.title("Histograma de la imagen a color")
    plt.xlabel("Rango de colores (0 Rojo, 120 Verde, 240 Azul, 360 Rojo)") 
    plt.ylabel("Numero de pixeles") 
    plt.bar(x, y, color ="red")
    grafica = utilities.fig2img(plt.gcf())
    plt.clf()
    return grafica

def image_bn_to_fake_color(imagen,y_red,y_green,y_blue):
    
    imagen = imagen.convert('L')
    
    #SE GUARDA EN UN UNA TUPLA DE TUPLAS, CUYAS TUPLAS SON CADA TRIO RGB QUE SUSTITUIRA
    #AL TONO DE GRIS 
    grafica_rgb = tuple(zip(y_red, y_green, y_blue))
    
    old_image = imagen.load()
    ancho, alto = imagen.size
    new_image = []
    x=0; y=0
    while y < alto:
        tono_gris = old_image[x,y]
        red = int(grafica_rgb[tono_gris][0]*255)
        green = int(grafica_rgb[tono_gris][1]*255)
        blue = int(grafica_rgb[tono_gris][2]*255)
        pixel = (red,green,blue)
        new_image.append(pixel)
        x+=1
        if x >= ancho:
            x=0
            y+=1
    
    sol = PIL.Image.new("RGB", (ancho, alto))
    sol.putdata(new_image)
    return sol

def varianza_minima(imagen):
    # Convertir la imagen a escala de grises
    imagen_gris = imagen.convert('L')
    pixels = list(imagen_gris.getdata())

    # Número de iteraciones máximo
    max_iteraciones = 10

    # Inicializar umbral inicial
    umbral = (np.mean(pixels) + np.max(pixels)) / 2

    for iteracion in range(max_iteraciones):
        # Calcular los valores medios de los dos segmentos
        segmento_0 = [pixel for pixel in pixels if pixel <= umbral]
        segmento_1 = [pixel for pixel in pixels if pixel > umbral]

        mu_1 = np.mean(segmento_0)
        mu_2 = np.mean(segmento_1)

        # Calcular el umbral para esta iteración
        nuevo_umbral = (mu_1 + mu_2) / 2

        # Verificar si el umbral ha convergido
        if abs(nuevo_umbral - umbral) < 0.5:
            break

        umbral = nuevo_umbral

    # Binarizar la imagen con el umbral final
    nueva_imagen = Image.new('L', imagen_gris.size)
    nuevos_pixels = [0 if pixel <= umbral else 255 for pixel in pixels]
    nueva_imagen.putdata(nuevos_pixels)
    
    grafica = histograma_blanco_negro(nueva_imagen)

    return nueva_imagen, grafica

def sliding(imagen):
    pass

def varianza(imagen):
    ancho, alto = imagen.size
    if imagen.mode != 'L':
        imagen = imagen.convert("L")
    imagen = imagen.load()
    new_array=[]
    x=0
    y=0
    while y < alto:
        new_array.append(imagen[x,y]) 
        x+=1
        if x >= ancho:
            x=0
            y+=1
            
    return s.mean(new_array)

def binarizacion_por_umbral(imagen, umbral):
    ancho, alto = imagen.size
    if imagen.mode != 'L':
        imagen = imagen.convert("L")
    imagen = imagen.load()
    new_image=[]
    x=0
    y=0
    while y < alto:
        if imagen[x,y] > umbral:
            new_image.append(255)
        else:
            new_image.append(0) 
        x+=1
        if x >= ancho:
            x=0
            y+=1
    
    sol = PIL.Image.new("L", (ancho, alto))
    sol.putdata(new_image)
    return sol

def binarizacion_entorno(imagen, entorno):
    ancho, alto = imagen.size
    if imagen.mode != 'L':
        imagen = imagen.convert("L")
    imagen = np.array(imagen)
    new_image = np.zeros_like(imagen,dtype=np.uint8)
    
    for y in range(alto):
        for x in range(ancho):
            #Asigana los valores dependiendo de la cantidad de pixeles con los que se quiere hacer la media 
            if entorno in range(3, 16, 2): 
                y1 = y - (entorno // 2)
                y2 = y + (entorno // 2) + 1
                x1 = x - (entorno // 2)
                x2 = x + (entorno // 2) + 1
            else:
                y1 = y - 1
                y2 = y + 2
                x1 = x - 1
                x2 = x + 2
            vecinos = []
            for i in range(max(0,y1), min(alto, y2)):
                for j in range(max(0, x1), min(ancho, x2)):
                    if (i, j) != (y, x):
                        vecinos.append(imagen[i, j])

            media = sum(vecinos) / len(vecinos)
            if imagen[y, x] > media:
                new_image[y, x] = 255
            else:
                new_image[y, x] = 0

    return Image.fromarray(new_image, 'L')

if __name__ == '__main__':
    pass    
    '''
    imagen_binarizada = binarizar_por_media_entorno('mujer.jpg')
    cv2.imshow('Imagen Binarizada', imagen_binarizada)
    cv2.waitKey(0)
    cv2.destroyAllWindows()
    '''
